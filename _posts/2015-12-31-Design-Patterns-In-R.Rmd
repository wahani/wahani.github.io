---
layout: post
title: Design Patterns in R
description: ""
comments: false
math: true
tags: [r, fp]
archive: true
---

These notes are inspired by 

- [a talk by Stuart Sierra](http://www.infoq.com/presentations/Clojure-Design-Patterns) on *Design Patterns in Functional Programming* and 
- some thoughts I found on [F# for fun an profit](http://fsharpforfunandprofit.com/)

I keep my notes using *R*. As an ongoing example I use a fixed point algorithm
to compute the square root of a positive real number. The algorithm is defined
as:

$$ x_{n + 1} = f(x_{n}) $$

and the fixed point function to find the square root is given by:

$$ f(x | p) = \frac{p}{x} $$

where \\(p\\) is a given (positive) value for which we want to find the square root.
To represent this in *R* I define the algorithm as:

```{r}
fp <- function(f, x, converged, ...) {
  value <- f(x, ...)
  if (converged(x, value)) value
  else Recall(f, value, converged, ...) 
}
```

\\(x\\) is the value of the last iteration or the starting value. `converged` is a
function with two arguments and `...` can be used for currying in *R*. Let the
fixed point function be defined as:

```{r}
fpsqrt <- function(x, p) p / x
```

and 

```{r}
converged <- function(x, y) all(abs(x - y) < 0.001)
```

So everythings set, lets compute that value:

```{r error=TRUE}
fp(fpsqrt, 2, converged, p = 2)
```

And as so often nothing really works the first time. In the current 
implementation it is also kind of hard to find out what is going wrong but we 
will get there. In the following I will apply different patterns to modify the
above framework to get to a solution.


# Wrapper Pattern

The *Wrapper Pattern* is something I use to add some functionality to a
function, without actually changing it. One of the things I do is adding a
logger to a function or taking care that a function prserves attributes, which
is not the case for many functions in *R*. Something else would be to try to 
call a function and retry every two minutes because of a failing connection to a
database or a file system that is not responding.

The main reason here is that I just do not want add that line to a function. A
function has a single, well defined purpose; logging and writing to a database
are two things. Computing the next iteration and keeping track of the number of
iterations are also two things. And things tend to add up, and that one feature
(with an additional argument of logging yes/no) will not be alone for long.

The problem in my example is that the fixed point function osciliates between
two values instead of converging against the square root. A trick to overcome
this is to use *average damping*. This means that instead of directly taking the
value \\(x\_\{n\}\\) for computing \\(x\_{n + 1}\\) we use \\(\frac{x_{n - 1} + 
x_n}{2}\\). And this is actually not part of the logic of the fixed point 
function so it should not be polluted with it:

```{r}
averageDamp <- function(fun) {
  function(x, ...) (x + fun(x, ...)) / 2
}

fp(averageDamp(fpsqrt), 2, converged, p = 2)
# and to compare:
sqrt(2)
```

Okay, great, now it seems to work. An additional wrapper I want to have is for
printing the value in each iteration to the console:

```{r}
printValue <- function(fun) {
  function(x, ...) {
    cat(x, "\n")
    fun(x, ...)
  }
}

fp(printValue(averageDamp(fpsqrt)), 2, converged, p = 2)
```

The problem now becomes that if we add to many wrappers it gets complicated.
Actually try to figure out which wrapper is called first, maybe that is not
obvious to you yet.

The wrapper pattern can be applied to add features *before* or *after* (or both)
the actual function. `printValue` adds the printing *before* and `averageDamp`
the correction *after* the original function. If we look at a different
formulation of `averageDamp` the pattern becomes more obvious:

```{r}
averageDamp <- function(fun) {
  function(x, ...) {
    value <- fun(x, ...)
    (x + value) / 2
  }
}
```


# Interface Patterns

## Currying

The value of this technique - from my perspective - is that you can build
interfaces more easily (with sufficient support of the language). For example
the fixed point function for the square root needs two arguments. The algorithm,
however, actually knows only about one argument. Currying in this case simply 
means to make the two-argument function `fpsqrt` into a one-argument function.
We can do this by setting \\(p = 2\\) which is what I accomplished using the
`...` so far.

In *R* you have two native options to model currying. The one you see most of 
the time is to use the dots argument to allow to pass additional arguments to 
the function. However, this puts an additional burden to every implementation in
my framework because I need to take care that I allow for dots in every wrapper
function I define. The other option is to use an anonymous function to wrap the
original version in an one-argument function which would look like this:

```{r}
fp(averageDamp(function(x) fpsqrt(x, p = 2)), 2, converged)
```

If I rely on this interface (one-argument function) I can get rid of all the 
dots. However the syntactical support of this technique is limited in *R* which
is why there is a different style support by packages like 
[purrr](https://cran.r-project.org/package=purrr) and 
[rlist](https://cran.r-project.org/package=rlist) which is to use formulas; And
packages like [functional](https://cran.r-project.org/package=functional) and
[pryr](https://cran.r-project.org/package=pryr) provide dedicated functions for
currying.

## Closures

Every function in *R* is a closure (except primitive functions). A closure is a
function which has an environment ascociated to it. E.g. a function
in a R-package has access to the packages namespace or a method in a class as in
object orientation has access to the scope of the class. But typically the term 
is used when functions are returned from other functions (except *R*s error 
message whenever you try to *subset a closure*). If you don't know about them,
but want to, you can read [this article]({% post_url 2014-09-23-Promises-and-Closures-in-R %}) or the chapter in [Advanced R](http://adv-r.had.co.nz/Functional-programming.html#closures).

For my example I use a closure to redefine the fixed point function for the
square root for a *given* value of \\(p\\). Where I think that the 
*given-value-of-p* part is only emphasized by the following implementation:

```{r}
fpsqrt <- function(p) {
  function(x) p / x
}
```

And this actually makes the call of the algorithm a bit more concise:

```{r}
fp(averageDamp(fpsqrt(2)), 2, converged)
```


# Cache Pattern

In various situations I want to cache some results instead of recomputing them.
This I do for performance reasons because no matter which library you use, the
time to compute an inverse is not linear in the sample size. Once you have
10.000 observations and compute the inverse of a \\((10.000 \times 10.000)\\)
variance-covariance matrix combined with a bootstrap in a Monte-Carlo simulation
study you have to wait. To illustrate this I want to compute a linear estimator.
And although the estimator can be identified analytically I use the fixed point
algorithm. The fixed point function (or Newton-Raphson) is defined as:

$$
\beta_{n + 1} = \beta_n - (f''(\beta_n))^{-1} f'(\beta_n) 
$$

with 

$$
f'(\beta) = X^\top (y - X\beta) \\
f''(\beta) = -X^\top X
$$

are the first and second derivatives for \\(\beta\\) of the likelihood under a 
normal distribution. If this does not mean anything to you, just ignore it and
try to figure out the pattern. Consider the following implementation in *R*
where I already applied the interface pattern using a closure:

```{r}
nr <- function(X, y) {
  function(beta) beta - solve(-crossprod(X)) %*% crossprod(X, y - X %*% beta)
}

# some data to test the function:
set.seed(1)
X <- cbind(1, 1:10)
y <- X %*% c(1, 2) + rnorm(10)

# Average damping in this case will make the convergence a bit slower:
fp(printValue(averageDamp(nr(X, y))), c(1, 2), converged)
# And to have a comparison:
stats::lm.fit(X, y)$coefficients
```

The results look promissing. We should choose a different tolerance level,
which at the moment is chosen very liberal, to get closer to *R*s
implementation; but that is not the focus here. What I want to do now is to make
the returned function of `nr` rely on some calculations to avoid that they are
recomputed in every iteration. In my code this very often comes with the
definition of local function:

```{r}
nr <- function(X, y) {
  
  # f1 relies on values in its scope:
  f1 <- function(beta) Xy - XX %*% beta
  
  Xy <- crossprod(X, y)
  XX <- crossprod(X)
  f2inv <- solve(-XX)
  
  function(beta) beta - f2inv %*% f1(beta)
  
}

fp(averageDamp(nr(X, y)), c(1, 2), converged)
```

Some remarks:

- local function definitions like `f1` in the above example, where I am sure to
control the environment, are the only places where I rely on free variables.
I.e. `f1` relies on `Xy` and `XX` which are values defined in the enclosing
environment; which I avoid at all cost in a user level function.
- I like this representation because I keep the logic of the fixed point
function local to `nr`; that function knows everything there is to know about
how to compute the next iteration, given the data. A different approach is to
define `nr` such that it expects `XX`, `Xy` and `f2inv` as arguments, which
means some other part of my code has to know about the implementation in `nr`
and I have to look at different places to understand how the next iteration is
computed.

There are two native ways to create a closure. The first one is to use really a
function with a function as return value; the second is to use the function
`local` which makes sense if you want initialize only one instance of a closure.
To illustrate what this means consider the following counter function:

```{r}
# Option 1:
counterConst <- function() {
  # like a constructor function
  i <- 0
  function() {
    i <<- i + 1
    i
  }
}
counter <- counterConst()
counter()
counter()

# Option 2:
counter <- local({
  i <- 0
  function() {
    i <<- i + 1
    i
  }
})
counter()
counter()
```

I remember that closures are hard to understand because as in the above example 
they can be used to model mutable state when almost everything in *R* is 
immutable. I probably banged my head against the wall for a couple of hours over
one of Hadleys examples to get the idea. For me there are three scenarios in
which I consider to use a closure:

- modelling mutable state; like counting the number a function has been called,
e.g. in an algorithm
- to build interfaces instead of using dots or anonymous functions
- to cache expensive computations and reuse results across multiple calls of a
function

Consider the case where we have a *very* expensive fixed point function. There
is data which is given and maybe some part of the computation could be cached,
e.g. computing an inverse. Of course you can simply hand a precomputed part as
argument to the fixed point function. However, that would mean that the
implementation of the fixed point function is more and more distant from the
mathematical representation, something I like to avoid.


Another example is to implement a wrapper function which modifies the
convergence criterion such that the algorithm will terminate after a given
number of iterations:

```{r}
addMaxIter <- function(fun, maxIter) {
    count <- 0
    function(...) {
        count <<- count + 1
        if (count >= maxIter) TRUE else fun(...)
    }
}
```

This allows us to explore the error which occured in the initial example:

```{r}
fp(printValue(fpsqrt(2)), 2, addMaxIter(converged, 4))
```

Now we can see that in the initial version of the algorithm osciliates between 1 and 2.